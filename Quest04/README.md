# Quest 04. OOP의 기본

## Introduction

- 이번 퀘스트에서는 바닐라 자바스크립트의 객체지향 프로그래밍에 대해 알아볼 예정입니다.

## Topics

- 객체지향 프로그래밍
  - 프로토타입 기반 객체지향 프로그래밍
  - 자바스크립트 클래스
    - 생성자
    - 멤버 함수
    - 멤버 변수
  - 정보의 은폐
  - 다형성
- 코드의 재사용

## Resources

- [MDN - Classes](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes)
- [MDN - Inheritance and the prototype chain](https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
- [MDN - Inheritance](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Inheritance)
- [Polymorphism](https://medium.com/@viktor.kukurba/object-oriented-programming-in-javascript-3-polymorphism-fb564c9f1ce8)
- [Class Composition](https://alligator.io/js/class-composition/)
- [Inheritance vs Composition](https://woowacourse.github.io/javable/post/2020-05-18-inheritance-vs-composition/)

## Checklist

- 객체지향 프로그래밍은 무엇일까요?
  체지향 프로그래밍(Object-Oriented Programming, OOP)은 프로그램을 구성하는 요소를 객체(Object)로 보고, 객체 간의 상호작용을 통해 프로그램을 구현하는 프로그래밍 패러다임이다.
  객체는 데이터와 그 데이터를 조작하는 메서드(Method)로 구성된다. 객체는 개별적으로 존재하며, 서로 다른 객체 간에는 독립적으로 작동한다. 이러한 객체 간의 상호작용을 통해 프로그램이 동작하며, 객체는 다른 객체와 연관되어 일을 수행하게 된다.
  객체지향 프로그래밍은 코드의 재사용성과 유지보수성을 높일 수 있으며, 대규모 프로젝트에서 특히 효과적입니다. 또한 객체지향 프로그래밍은 개발자의 생각을 객체화하므로, 코드의 가독성과 유지보수성을 향상시키는 효과가 있다.

  - `#`로 시작하는 프라이빗 필드는 왜 필요한 것일까요? 정보를 은폐(encapsulation)하면 어떤 장점이 있을까요? #로 시작하는 프라이빗 필드는 ES2019부터 추가된 자바스크립트의 기능으로, 클래스의 인스턴스 변수를 외부에서 직접 접근하지 못하도록 보호하는 역할을 한다. 이는 정보 은폐(encapsulation)의 한 방법으로, 객체 지향 프로그래밍에서 매우 중요한 개념 중 하나아다.

    안전한 코드: 정보 은폐를 통해 클래스 내부의 상태를 외부에서 직접 변경하는 것을 막을 수 있으므로, 예상치 못한 버그를 방지할 수 있다.
    코드 재사용: 정보 은폐를 통해 클래스 내부의 상태를 캡슐화할 수 있으므로, 다른 부분에서도 해당 클래스를 쉽게 재사용할 수 있다. 이는 코드의 유지보수성을 높이고, 중복 코드를 방지할 수 있는 장점이 있다.
    코드 가독성: 정보 은폐를 통해 클래스 내부의 상태와 동작을 명확하게 구분할 수 있으므로, 코드의 가독성을 높일 수 있다.

    따라서 정보 은폐는 객체 지향 프로그래밍에서 매우 중요한 개념 중 하나이며, #로 시작하는 프라이빗 필드는 이를 구현하는 데에 있어서 유용한 도구이다.

  - 다형성이란 무엇인가요? 다형성은 어떻게 코드 구조의 정리를 도와주나요?
    다형성(Polymorphism): 같은 이름의 메서드가 다른 기능을 수행하도록 하는 것을 의미한다. 다형성을 통해 코드의 가독성과 유지보수성을 향상시킬 수 있다.

  - 상속이란 무엇인가요? 상속을 할 때의 장점과 단점은 무엇인가요?
    상속(Inheritance): 부모 클래스가 가지고 있는 속성과 메서드를 자식 클래스가 물려받는 것을 의미한다. 상속을 통해 코드의 재사용성과 유지보수성을 향상시킬 수 있다.

  - OOP의 합성(Composition)이란 무엇인가요? 합성이 상속에 비해 가지는 장점은 무엇일까요?
    객체 지향 프로그래밍에서 합성(Composition)은 다른 객체를 조합하여 새로운 객체를 만드는 기법이다. 이는 객체 간에 강한 결합을 피하고, 유연하고 모듈화된 코드를 작성할 수 있게 한다.

    1. 코드 재사용: 상속과 달리 합성은 두 개 이상의 객체를 조합하여 새로운 객체를 생성할 수 있으므로, 코드의 재사용성을 높일 수 있다.

    2. 유연성: 합성을 사용하면 각 객체를 개별적으로 수정하거나 교체할 수 있으므로, 코드의 유연성을 높일 수 있다.

    3. 객체 간 결합도 감소: 합성을 사용하면 객체 간의 결합도가 낮아지므로, 코드의 유지보수성이 향상된다.

    상속과 비교하여 합성의 가장 큰 장점은 유연성과 객체 간의 결합도 감소이다. 상속은 하위 클래스와 상위 클래스 간의 강한 결합을 유발할 수 있으며, 부모 클래스의 변경이 하위 클래스에 영향을 미칠 수 있다. 그러나 합성은 이러한 문제를 방지하면서도 코드의 재사용성과 유지보수성을 높일 수 있는 장점이 있다. 따라서 합성은 객체 지향 프로그래밍에서 권장되는 기법 중 하나이다.

- 자바스크립트의 클래스는 어떻게 정의할까요?
  객체를 직접 작성하여 정의하고 생성할 수도 있지만, 클래스로 만들어주면 여러 객체를 더 쉽게 만들 수 있다. 클래스는 객체를 생성하기 위한 템플릿이다.
  ES6부터 추가된 class는 직관적으로 쉽게 코드를 읽을 수 있게 만들어 줄 뿐만 아니라, 작성하기도 쉽고 또 class 기반 언어에 익숙한 개발자가 더 빠르게 적응할 수 있다.

  - 프로토타입 기반의 객체지향 프로그래밍은 무엇일까요?
    프로토타입 기반의 객체지향 프로그래밍(Prototype-based Object-Oriented Programming)은 객체를 생성하는 일종의 패턴으로, 객체를 생성하기 위한 클래스(또는 생성자 함수)를 사용하는 대신에, 다른 객체를 복사하거나 연결(참조)하는 방식으로 객체를 생성한다.

    이러한 패턴에서는 객체를 생성하기 위해 클래스를 정의할 필요가 없으며, 대신에 이미 존재하는 객체를 복사하거나 연결하는 방식으로 객체를 생성한다. 이 때, 객체를 복사하거나 연결할 때 사용하는 객체를 프로토타입(Prototype)이라고 한다.

    객체의 프로퍼티나 메소드를 참조할 때, 먼저 해당 객체에 해당하는 프로퍼티나 메소드를 찾고, 없으면 해당 객체의 프로토타입에 해당하는 프로퍼티나 메소드를 찾는다. 이러한 방식으로 프로토타입 체인(Prototype Chain)을 따라가면서 객체가 가지는 프로퍼티나 메소드를 찾아나간다.

    프로토타입 기반의 객체지향 프로그래밍은 클래스 기반의 객체지향 프로그래밍과 비교하여 상속이나 객체 간의 관계를 보다 유연하게 다룰 수 있으며, 코드의 재사용성을 높일 수 있는 장점이 있다. 그러나 코드의 가독성이나 유지보수성 측면에서는 클래스 기반의 객체지향 프로그래밍보다 다소 불편할 수 있다.

  - 자바스크립트의 클래스는 이전의 프로토타입 기반의 객체지향 구현과 어떤 관계를 가지고 있나요?
    ES6(2015)부터 도입된 자바스크립트의 클래스(Class)는 이전의 프로토타입 기반의 객체지향 구현과 근본적으로 다른 것은 아니고, 프로토타입 기반 패턴을 쉽게 사용하기 위한 문법적인 도구일 뿐이다. 클래스는 생성자 함수와 프로토타입 객체를 쉽게 생성하고 상속을 지원하는 문법적인 도구이다.

    즉, 클래스는 생성자 함수와 프로토타입 객체를 생성하는 복잡한 작업을 쉽게 처리할 수 있도록 문법적인 도구를 제공하는 것이다. 클래스를 이용해 객체를 생성하면, 내부적으로는 여전히 프로토타입 기반의 객체 생성 패턴이 사용된다. 따라서 클래스를 사용하는 것은 프로토타입 기반의 객체 생성 패턴과 같은 개념적인 모델을 그대로 유지하면서 구현하는 것이다.

## Quest

- 웹 상에서 동작하는 간단한 바탕화면 시스템을 만들 예정입니다.
- 요구사항은 다음과 같습니다:
  - 아이콘은 폴더와 일반 아이콘, 두 가지의 종류가 있습니다.
  - 아이콘들을 드래그를 통해 움직일 수 있어야 합니다.
  - 폴더 아이콘은 더블클릭하면 해당 폴더가 창으로 열리며, 열린 폴더의 창 역시 드래그를 통해 움직일 수 있어야 합니다.
  - 바탕화면의 생성자를 통해 처음에 생겨날 아이콘과 폴더의 개수를 받을 수 있습니다.
  - 여러 개의 바탕화면을 각각 다른 DOM 엘리먼트에서 동시에 운영할 수 있습니다.
  - Drag & Drop API를 사용하지 말고, 실제 마우스 이벤트(mouseover, mousedown, mouseout 등)를 사용하여 구현해 보세요!

## Advanced

- 객체지향의 역사는 어떻게 될까요?
- Smalltalk, Java, Go, Kotlin 등의 언어들로 넘어오면서 객체지향 패러다임 측면에서 어떤 발전이 있었을까요?
