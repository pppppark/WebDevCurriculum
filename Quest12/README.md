# Quest 12. 보안의 기초

## Introduction

- 이번 퀘스트에서는 가장 기초적인 웹 서비스 보안에 대해 알아보겠습니다.

## Topics

- XSS, CSRF, SQL Injection
- HTTPS, TLS

## Resources

- [The Basics of Web Application Security](https://martinfowler.com/articles/web-security-basics.html)
- [Website Security 101](https://spyrestudios.com/web-security-101/)
- [Web Security Fundamentals](https://www.shopify.com.ng/partners/blog/web-security-2018)
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)
- [Wikipedia - TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security)

## Checklist

- 입력 데이터의 Validation을 웹 프론트엔드에서 했더라도 서버에서 또 해야 할까요? 그 이유는 무엇일까요?
  입력 데이터의 validation은 웹 프론트엔드에서 수행하더라도, 서버 측에서도 해당 데이터를 다시 한번 검증하는 것이 좋다. 그 이유는 두 가지가 있다.

  첫째, 보안상의 이유이다. 악성 사용자는 클라이언트에서 전송하는 요청을 조작할 수 있다. 예를 들어, 브라우저 개발자 도구를 이용하여 HTML form 요소의 속성을 변경하거나, HTTP 요청을 보내는 프로그램을 이용하여 조작된 데이터를 전송할 수 있다. 이러한 조작된 데이터가 서버 측에서 validation을 거치지 않고 데이터베이스에 저장된다면, 데이터베이스나 애플리케이션에 보안 위험이 생길 수 있다. 서버 측에서 데이터를 검증함으로써 이러한 보안 위협을 예방할 수 있다.
  둘째, 데이터의 일관성을 유지하기 위해서이다. 서버 측에서도 입력 데이터의 validation을 검사함으로써, 데이터의 일관성을 유지할 수 있다. 예를 들어, 웹 페이지에서 회원 가입을 할 때, 사용자 이름이 이미 등록되어 있는지 서버 측에서 확인하는 경우가 있다. 이 경우, 클라이언트에서는 사용자 이름이 존재하지 않는다고 판단하여 가입을 하지만, 서버 측에서는 이미 해당 사용자 이름이 존재한다는 결과를 반환하여 가입을 거부할 수 있다.
  따라서, 클라이언트 측에서도 validation을 수행하더라도, 서버 측에서도 데이터의 validation을 수행하여 보안과 일관성을 유지하는 것이 좋다.

  - 서버로부터 받은 HTML 내용을 그대로 검증 없이 프론트엔드에 innerHTML 등을 통해 적용하면 어떤 문제점이 있을까요?
    서버로부터 받은 HTML 내용을 그대로 검증 없이 프론트엔드에 innerHTML 등을 통해 적용하는 것은 보안 상 매우 위험한 일이다. 이를 "신텍스 인젝션 (syntax injection)" 또는 "HTML 인젝션 (HTML injection)"이라고 한다.
    신텍스 인젝션은 주로 특수문자를 이용하여 해커가 악성 스크립트 코드를 주입하는 공격 방식이다. 해커가 이를 이용하여 사용자의 쿠키 정보나 개인 정보 등을 탈취하거나, 악성 스크립트를 실행시켜 서버에 대한 악의적인 공격을 시도할 수 있다.
    HTML 인젝션은 웹 애플리케이션이 동적으로 생성한 HTML 내용에 악성 스크립트 코드가 삽입되는 것이다. 이를 이용하여 해커는 사용자의 쿠키 정보나 개인 정보 등을 탈취할 수 있다.
    이러한 문제점을 방지하기 위해서는 입력 데이터의 검증을 서버에서도 수행해야 한다. 서버에서는 입력 데이터에 대해 필요한 검증을 수행하고, 필요한 경우 이를 클라이언트에 알려줌으로써 보안을 유지할 수 있다. 이를 통해 서버의 안전성을 보호하고, 사용자의 개인 정보 보호를 강화할 수 있다.

  - XSS(Cross-site scripting)이란 어떤 공격기법일까요?
    XSS(Cross-site scripting)는 웹 어플리케이션 취약점 중 하나로, 공격자가 웹사이트에 악성 스크립트를 삽입하여 다른 사용자들이 해당 스크립트를 실행하도록 유도하는 공격 기법이다. 이를 통해 공격자는 사용자의 정보를 탈취하거나, 세션 하이재킹 등 다양한 공격을 수행할 수 있다.
    XSS 공격은 보통 사용자의 입력값을 웹 어플리케이션에서 검증하지 않고 출력할 때 발생한다. 예를 들어, 게시판의 댓글 기능에서 사용자가 입력한 내용을 검증 없이 출력하는 경우, 악의적인 사용자는 스크립트를 삽입하여 해당 게시글을 읽는 다른 사용자들의 브라우저에서 스크립트를 실행시킬 수 있다.
    XSS 공격을 방지하기 위해서는 입력값을 검증하고, 출력할 때 특수문자를 이스케이프(escape)하여 브라우저가 스크립트를 실행하지 못하도록 해야한다. 또한, Content Security Policy(CSP)를 설정하여 외부에서 실행되는 스크립트나 리소스를 제한하는 것도 도움이 된다.

  - CSRF(Cross-site request forgery)이란 어떤 공격기법일까요?
    CSRF(Cross-site request forgery)은 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행동을 수행하도록 유도하는 공격 기법이다. 이 공격은 일반적으로 사용자가 웹사이트에 로그인된 상태에서 공격자가 만든 피싱 사이트에 방문하여 조작된 요청을 전송하도록 유도함으로써 수행한다.
    예를 들어, 은행 웹사이트를 이용하는 사용자가 로그인한 상태에서, 공격자가 이용자에게 이메일을 보내고, 해당 이메일에서 링크를 클릭하도록 유도한다. 이 링크는 공격자가 만든 피싱 사이트로 연결되어 있으며, 피싱 사이트는 은행 웹사이트와 똑같은 폼을 띄우면서 허위 정보를 입력하도록 유도한다. 이후 피싱 사이트에서 입력된 정보를 이용하여 은행 웹사이트로 요청을 보내면, 이용자는 자신이 요청을 보낸 것으로 인식하지 않으면서 공격이 성공한다.
    이를 방지하기 위해서는, 서버에서는 요청을 보낸 사용자가 로그인한 사용자인지 확인하고, 인증 토큰 등의 추가적인 정보를 요청에 포함시켜 검증을 수행한다. 클라이언트에서는 이러한 검증을 위해 쿠키 등의 정보를 이용하여 추가적인 검증을 수행할 수 있다. 또한 사용자에게 인증 토큰 등의 정보를 전달하고, 이를 이용하여 요청을 보내도록 유도함으로써 공격을 방지할 수 있다.

  - SQL Injection이란 어떤 공격기법일까요?
    SQL Injection은 웹 어플리케이션에서 발생할 수 있는 보안 취약점 중 하나로, 악의적인 사용자가 SQL 쿼리를 조작하여 데이터베이스를 비정상적으로 조작하는 공격 기법을 말한다.

    일반적으로 웹 어플리케이션에서는 입력된 데이터를 검증하여 쿼리문을 만들기 때문에, 사용자가 입력한 데이터에 SQL 문법을 삽입하여 쿼리를 조작하는 공격이 가능하다. 예를 들어, 로그인 폼에서 입력한 아이디와 비밀번호를 검증하는 쿼리문이 다음과 같다고 가정하면

    SELECT \* FROM users WHERE username = '아이디' AND password = '비밀번호';

    이 쿼리문에서 사용자가 입력한 아이디와 비밀번호가 각각 'admin'과 '1234'라고 한다면, 다음과 같은 쿼리문이 만들어진다.

    SELECT \* FROM users WHERE username = 'admin' AND password = '1234';

    하지만, 사용자가 아이디에 `admin'; --`와 같이 입력하면 다음과 같은 쿼리문이 만들어진다.

    SELECT \* FROM users WHERE username = 'admin'; --' AND password = '비밀번호';

    여기서 `--`는 주석 처리 기호로, 이후의 쿼리문은 무시한다. 따라서, 악의적인 사용자는 이를 이용하여 로그인 폼을 우회하여 데이터베이스를 조작할 수 있다.

    SQL Injection 공격을 방지하기 위해서는, 사용자로부터 입력받은 데이터를 검증하고 필터링하여 쿼리문 생성에 사용되는 모든 입력 데이터가 안전한지 확인해야한다. 또한, Prepared Statement와 같은 안전한 쿼리 생성 방식을 사용하거나, ORM 등의 라이브러리를 이용하여 SQL Injection 공격을 방지할 수 있다.

- 대부분의 최신 브라우저에서는 HTTP 대신 HTTPS가 권장됩니다. 이유가 무엇일까요?
  HTTP는 암호화되지 않은 평문 통신을 사용하기 때문에 제3자가 데이터를 볼 수 있고 조작할 수 있다. 반면 HTTPS는 SSL/TLS 프로토콜을 사용하여 데이터를 암호화하고 안전하게 전송할 수 있다. 이로 인해 HTTPS를 사용하면 중간자 공격 및 도청, 데이터 변조 등의 보안 위협을 줄일 수 있다.
  HTTPS는 인터넷에서 정보 보호를 위해 널리 사용되며, 브라우저에서 HTTPS를 사용하면 사용자가 입력한 민감한 정보(로그인 정보, 결제 정보 등)가 암호화되어 전송되기 때문에 해킹과 같은 공격으로부터 사용자를 보호할 수 있다. 또한, HTTPS는 검색 엔진 최적화(SEO)에도 도움이 된다. 구글은 HTTPS를 사용하는 웹 사이트를 선호하며 HTTPS를 사용하지 않는 웹 사이트는 검색 순위에서 밀릴 가능성이 있다.

  - HTTPS와 TLS는 어떤 식으로 동작하나요? HTTPS는 어떤 역사를 가지고 있나요?
    HTTPS(암호화된 HTTP)는 인터넷을 통해 데이터를 보안적으로 전송하기 위한 프로토콜
    HTTPS는 일반적으로 전송 계층 보안(TLS) 프로토콜을 사용하여 데이터를 보호한다.
    TLS는 SSL(Secure Sockets Layer) 프로토콜을 개선한 것으로, 클라이언트와 서버 간의 통신을 보호하기 위한 암호화 및 인증 메커니즘을 제공한다. TLS는 공개키 인프라(PKI)를 사용하여 클라이언트 및 서버의 인증과 데이터의 기밀성 및 무결성을 보장한다. TLS는 대부분의 웹 브라우저와 웹 서버에서 지원되며, HTTPS를 통해 안전한 데이터 전송을 제공한다.
    HTTPS는 HTTP와 달리 암호화된 연결을 사용하기 때문에 데이터의 기밀성과 무결성을 보호할 수 있다. 따라서 중간자 공격과 같은 공격으로부터 사용자 데이터를 보호할 수 있다. 또한, HTTPS는 인터넷 사용자들에게 서비스 제공자가 신뢰할 수 있는지 여부를 나타내는 SSL 인증서를 통해 보다 안전한 웹 서비스를 제공할 수 있다.
    HTTPS의 역사는 1994년 넷스케이프에서 처음 소개된 SSL 프로토콜과 밀접하게 연관되어 있다. 그러나 SSL은 2015년 이후에 취약점이 발견되어 TLS 1.0부터 1.3까지 각 버전이 발표되었으며, 현재는 TLS 1.3이 널리 사용되고 있다.

  - HTTPS의 서비스 과정에서 인증서는 어떤 역할을 할까요? 인증서는 어떤 체계로 되어 있을까요?
    HTTPS의 서비스 과정에서 인증서는 클라이언트가 접속한 서버가 신뢰할 수 있는 서버인지를 확인하기 위한 역할을 한다. HTTPS 통신에서 클라이언트와 서버 간에 암호화된 연결을 수립하기 위해서는 공개키 암호화 방식인 SSL/TLS 프로토콜을 사용한다. 이때 인증서는 서버 측에서 클라이언트에게 제공되며, 클라이언트는 인증서가 발급된 인증 기관(CA)의 신뢰도를 확인한 후에 SSL/TLS 프로토콜을 사용하여 서버와 안전한 통신을 할 수 있다.
    인증서는 공개키 기반 구조에서 사용되며, 일반적으로 X.509 표준에 따라 작성한다. 인증서는 서버의 공개키를 포함하며, 클라이언트는 이 공개키를 사용하여 서버의 개인키로 암호화된 SSL/TLS 세션 키를 전송한다. 인증서는 인증서의 발급 기관(CA)의 서명을 포함하여, 발급 기관의 신뢰성에 따라 검증한다.
    최근에는 Let's Encrypt와 같은 무료 인증 기관의 등장으로 인증서를 발급받는 과정이 간편해졌고, HTTPS를 사용하는 웹 사이트가 증가하면서 인터넷 통신의 보안성이 크게 향상되었다.

## Quest

- 메모장의 서버와 클라이언트에 대해, 로컬에서 발행한 인증서를 통해 HTTPS 서비스를 해 보세요.

## Advanced

- TLS의 인증서에 쓰이는 암호화 알고리즘은 어떤 종류가 있을까요?
- HTTP/3은 기존 버전과 어떻게 다를까요? HTTP의 버전 3이 나오게 된 이유는 무엇일까요?
